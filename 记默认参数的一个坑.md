## 记默认参数的一个坑

 众所周知，python的默认参数格式为：

```python
def fnuc(a,b=[]):
  pass
```

在函数定义时在参数的位置给个默认值；像上述例子中，当函数没有接收到参数b，则会自动传入一个赋值为[]的b作为参数；否则就根据调用时的参数来调用，最常见的应用就是：

```python
print(*objects, sep=' ', end='\n', file=sys.stdout)
```

平时我们用print就直接print(a)就完事了，后面就是默认值，当然我们也可以根据需求添加sep和end等参数，此时print就会传入我们输入的参数；

既然这样，那么以下这个例子：

```python
def func(a,b=[]):
    b.append(a)
    print(b)
func(1)
func(2,[0,])
func(3)
```

会出现什么结果？~~别问为啥那个列表这样写，反正相当于[0]~~

理论上应该会是：

```
[1]
[0,2]
[3]
```

但是实际上呢？

```
[1]
[0, 2]
[1, 3]
```

这什么操作？？？

但是事实摆在眼前，那就肯定是理论有问题 ~~（理论个毛单纯我自己理解错了）~~，下面来探究一下其原理；

稍微修改一下原代码：

```python
def func(a,b=[]):
    b.append(a)
    return b
li1 = func(1)
li2 = func(2,[0,])
li3 = func(3)
print(li1 is li2)
print(li2 is li3)
print(li1 is li3)
```

结果是：

```
False
False
True
```

所以，li1和li3是指向同一个地址的咯？？

找了好几个介绍这个现象的文章，都提到一句话：

> Default values are computed once, then re-used.

据说这句话出自官方文档（未证实），意思是 **默认参数会被复用**，就是字面意思；但是众所周知，python的数据类型分为可变和不可变类型，而例子中的list属于可变类型数据，那么对于不可变类型是否也是这样呢？

试验一下：

```python
def func(a = 0):
    a += 1
    return a
num1 = func()
num2 = func()
print(num1,num2)#1 1
```

结果是不可变数据就不会出现之前那种情况；

那么可以大概得出结论~~（结果论，虽然不太严谨？）~~：

**1、对于不可变类型设置为默认参数的情况，每次调用函数时默认参数都会另起新地址进行计算；**

**2、对于可变类型设置为默认参数的情况，每次调用函数时默认参数都会对原来的地址进行计算**

算是一个坑吧，平时用的时候会容易踩到，所以还是记录一下；~~（其实更多的是出现在面试中）~~

那么假如我们想用list作为默认参数但是又不想每次不传入参数时的调用都对同一个列表进行操作该怎么办呢？

非常简单！

```python
def func(a,b=[]):
    if b == []:
        b = [] #看着逻辑很魔幻吧
    b.append(a)
    return b
li1 = func(1)
li2 = func(2,[0,])
li3 = func(3)
print(li1,li2,li3)# [1] [0,2] [3]
```

整个初始化就好了！







[返回首页](https://ko710395.github.io/)