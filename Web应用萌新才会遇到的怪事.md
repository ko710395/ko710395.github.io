## Web应用萌新才会遇到的“怪事”

​		事先声明，这个 “怪事” 是仅限对于web端萌新来说的，其实我大学时期做期末大作业的时候就遇到了，当时时间不够没解决完最后凭借运气才过的关，之后就不了了之了；直到去年刚初学Python Web端时为了写而写的一个[练手项目](https://github.com/ko710395/Library)~~（不建议看，当初边学边写的很辣眼睛，毫无参考价值）~~，结果又出现了这个问题，由于一开始搜索的思路就错了，导致我在网上查了几天才最终理解并解决问题；然后现在开始XJB搞了个博客，就想着把这件事记下来好了，就当是个随笔；~~（反正也没人看）~~

​		ps：这是一篇叙事文，不是学术论文，所以会比较冗长也不全是干活；



#### 现象描述：

​		由于我两次遇到这个问题都是使用的MySQL，因此我不确定其他数据库是否会出现同样的问题，虽然就算有的话理解了问题后也有办法解决；

​		web端应用经常会用到数据库的crud，这也是基础中的基础（不仅对于web），因此表单提交后写入数据库这种操作就随处可见，比如最简单的注册功能；

​		然后神奇的现象就出现了，有些表单提交功能实现后，以我那个丢人的练手项目为例，图书加入用户收藏夹后，然后立刻在网页端查看用户是否收藏了该图书（在项目中是一个按钮，进行相应操作前前端会向后台请求，后台会进行一次表单查询，如果该图书用户已经收藏了则显示“取消收藏”，否则就是“加入收藏”），然后我点了“加入收藏”，表单提交了，页面刷新了，然后再点开，发现按钮还是“加入收藏”？？？难道根本没写进表里？？？

​		扭头去查看SQL表，不对啊明明写进去了啊为啥查表出来的结果是未加入收藏？？？更神奇的是我原地多次刷新页面，居然会偶尔出现“加入收藏”按钮，偶尔是“取消收藏”按钮，然后我前端打印出来后台返回结果，居然也是偶尔已收藏偶尔未收藏，明明在本地终端直接查询SQL表上面清清楚楚黑底白字写着表里有加入收藏的那个东西，这TM到底什么鬼？？？然后整个后台重启了之后，就只会出现表被修改后的数据了。

​		总的来说就是：

​			**终端里查询SQL表的结果和后台查询SQL的结果“偶尔”不一样，除非后台重启**

但是你不可能一个web应用每次提交表单后都重启一次后台这么搞笑吧？

是真的神奇：）

先看下查询部分的代码，

使用的是flask的SQLAlchemy：

```python
def what_like(): # 查看收藏夹
        li = []
        res = Relationship.query.filter(Relationship.id == current_user.id).first() #真正查询的只有这行，因为表的结构设计有问题，专门有一个收藏夹的关系表但是里面并没有书的详细信息
        x = 1
        while x < len(res.books)-3:
            li.append(res.books[x:x+4])
            x = x + 5
        li2 = []
        for y in li:
            res = Books.query.filter(Books.id == y).first()#根据上一次查询到的书名又在书的表里查询详细信息，因为收藏夹是之后才想起来加的功能
            li2.append({'Name' : res.Name,
                        'Author' : res.Author,
                        'PublishingHouse' : res.PublishingHouse,
                        'Category' : res.Category,
                        'id' : res.id})#整理好之后返回给前端
        return jsonify(
            success = True,
            data = li2
        )
```

代码并没有什么问题，那为什么会出现上述的现象呢？



#### 解决办法：

突然有一天，我灵光一现，脑袋被一道雷击穿一样突然感觉这个现象有点像是之前的结果被“缓存”了，于是我就顺着这个思路就找资料，还真给我找到了 ；

[从SQLAlchemy的“缓存”问题说起](https://www.jianshu.com/p/c0a8275cce99)

更详细的信息请看上面的链接，下面是我自己的简单理解和简单转述，毕竟这只是我自己的笔记；

​		首先，SQLAlchemy的查询是会有缓存的，第二次查询是会查询到第一次查询的缓存结果，想测试的大佬可以试试打开SQLALCHEMY_ECHO，设置为true后SQLAlchemy执行的操作都会反映在终端上，一般来说对同一表项的第二次查询时终端不会显示类似“ SELECT * FROM XXX"这样的语句，而第一次会，因此第二次查询应该就是读取了第一次查询的结果，并没有直接查表；那么如果我们不希望第二次查询读取缓存而是直接查表呢？SQLAlchemy同样有办法；

以下是SQLAlchemy几种清除缓存的办法：

>expire：会清除缓存数据，下次查询就会直接去查表；
>
>expire_all：和上面一样，只是会清除session里所有对象的缓存；
>
>refresh：清除缓存后还会立刻出发一次数据库查询来更新数据；
>
>flush：把本地修改全都写入数据库，但不会提交到数据库；
>
>commit：同上前半条，但是会提交这个事务；

于是在每次查询前分别执行上述语句发现，只有commit能真正做到清除缓存，显示实时的数据；

那么在讨论原因之前就能得出结论了：

遇到这种问题时，只要**每次查询前都先commit()一次**就完事了；

OK问题解决了，但是为什么只有commit才有效呢？

下面就是讨论这个问题了，当然之后的内容是数据库相关的东西，和代码没太直接的关系；



#### 深入分析：

​		从上述各方法的特性和控制变量法来考虑，commit奏效的关键就是在于后半段的”提交事务“，因为前半段清除缓存其他方法都有这步操作，那问题就肯定跟数据库的事务有关；

​		数据库中有个东西叫”事务隔离“，是一个分级的玩意儿，它决定了数据的可见性，四种等级及其属性如下表：

| 隔离级别       | 脏读   | 不可重复读 | 幻读   |
| -------------- | ------ | ---------- | ------ |
| 未提交读（RU） | 可能   | 可能       | 可能   |
| 已提交读（RC） | 不可能 | 可能       | 可能   |
| 可重复读（RR)  | 不可能 | 不可能     | 可能   |
| 可串行化       | 不可能 | 不可能     | 不可能 |

那么来解释一下表里的名词：

- 脏读（dirty read）：一个事务可以读到其他事务还未提交的数据；
- 不可重复读（non-repeatable read）：同一事务中的同一行被多次读取后，可以读到不同的值；
- 幻读（phantom read）：一个事务中执行统一语句多次后，读到的数据行发生改变，就是可能读到的行数多了或者少了；

根据介绍可以发现，上面这个现象其实就是跟这个不可重复读属性相关的，然后对MySQL来说，数据库的默认事务隔离等级是RR，因此是不能不可重复读的，就是可以读到不同数据的意思；

那么为什么会有读到不同数据的情况出现呢？下面就用一个时序图来解释一下不可重复读：

| 事务A                                                        | 事务B                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Begin                                                        | Begin                                                        |
| SELECT books FROM table1 where id = 1; /\*返回table1中id为1的books这一列数据，设结果为a；*/ |                                                              |
|                                                              | UPDATE table1 SET books = b WHERE id = 1; /*修改id = 1的书为b；\*/ |
|                                                              | COMMIT;                                                      |
| SELECT books FROM table1 where id = 1; /*再查一次\*/         |                                                              |
| COMMIT;                                                      |                                                              |

可以看到，这种情况下就会出现同一数据不同查询时出现不同结果的现象；

所以根据上述的情况分析，解决办法就有两种：

1、另起一个事务，这样不可重复读的前提条件就不存在了，即在同一事务中这个条件不存在，SQLAlchemy的commit方法就是另起了一个事务；

2、调整数据库事务隔离等级到RC，但是这种大修改除非真的有需要，否则不太建议这么做，鬼知道会不会对你其他和数据库的交互造成影响；

综上所述，这个问题最核心的解决办法就是另起事务（真的要调整事务隔离等级就当我没说），在SQLAlchemy中就是commit，在其他orm或者数据库中也是同样的道理；

链接的文章中最下面还有讨论Flask-SQLAlchemy的自动提交的问题，但似乎这项特性在flask2.0版本中移除了，所以就不再讨论了；



 

[返回首页](https://ko710395.github.io/)