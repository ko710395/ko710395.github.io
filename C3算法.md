# C3算法

​		根据[之前这篇笔记](https://ko710395.github.io/super函数)里介绍的super函数，super函数执行的顺序是根据调用时使用的实例来决定用哪个mro表的，那么这篇笔记就来记录一下，这个mro表是怎么得到的。

​		这篇笔记纯粹是好奇想探究个清楚才去查阅资料学习的，是属于比较进阶的内容，能提升对super函数的理解，但是直接的实用性应该是用不太上的；另外虽然标题是C3算法，但是C3是一个比较广的定义，C3的意思是：

- 一致扩展前趋图，
- 本地前趋序的保持，
- 适于单调标准

**节选自百度百科*

但在这篇笔记中只介绍python中用于计算出mro表的那个C3算法；（其实有没有别的C3算法我也不太清楚，先说明比较好）

继续沿用之前那篇笔记的例子：

```python
class A:
    pass

class B(A):
    pass


class C(A):
    pass


class D(B, C):
    pass

```

简化了好看一点，其实我们只要用到它们的继承关系，大概这样：

​	↙ B ↖

A				D

​	↖ C ↙

B和C分别继承自A，D同时继承自B和C；

在之前那篇笔记里有提到，D的mro表是DBCAO，而B的则是BAO（O指最后的object类）；

为了说明简单，我就直接以ABC的mro表都有结果的前提下介绍D的mro表如何生成的，毕竟直接介绍最复杂的前面的也迎刃而解了；

##### 其实计算mro表的过程就是不断merge这个类的父类们的mro表；

首先，mro表的第一个必定是自己；所以最终的mro表就是：

​		D.mro = D + merge(B.mro, C.mro)

B和C的顺序根据D的继承顺序，先来后到；由前提可得：B.mro = [B, A, O]，C.mro=[C, A, O]，那就来merge这两个mro表；

这个merge是个什么操作呢？

当merge到的元素符合两个条件之一时就加入目标列表并从所在列表中删除（当然是临时的，不影响原列表）：

- 只有这个列表有这个元素时；
- 其他列表也有这个元素，但都是第一个元素时；

另外一个特殊情况就是，当其他列表也有这个元素且在其他列表中这个元素不是第一个时，那加入目的列表的且从原列表中删除的就是那个其他列表中的第一个元素；

看着有点乱吧？实际来一次就知道了；

### 计算过程：

开始时的状态：

D.mro = [D]

B.mro = [B, A, O]

C.mro = [C, A, O]

第一步：查看B.mro，第一个元素是B，然后查看C.mro，里面并没有B，因此从B.mro里删除B，将B加入D.mro，此时状态：

D.mro = [D, B]

B.mro = [A, O]

C.mro = [C, A, O]

第二步：继续查看B.mro，第一个元素是A，然后查看C.mro，里面有A，但是C中存在比A更靠前的元素C，因此从C.mro中删除C，并将C加入到D.mro，此时状态：

D.mro = [D, B, C]

B.mro = [A, O]

C.mro = [A, O]

第三步，继续查看B.mro，第一个元素仍是A，然后查看C.mro，里面也有A，且A也是C中的第一个元素，因此同时从B.mro和C.mro中删除A，并将A加入到D.mro中，此时状态：

D.mro = [D, B, C, A]

B.mro = [O]

C.mro = [O]

第四步，与上一步同理，执行后的状态：

D.mro = [D, B, C, A, O]

B.mro = []

C.mro = []

此时待merge的两个参数都空了，执行结束，至此我们就得到了要求的D.mro = [D, B, C, A, O]，OVER!







[返回首页](https://ko710395.github.io/)